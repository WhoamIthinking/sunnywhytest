# sunnywhy算法笔记

**==从现在开始这几道题遇到不会的我就开始写笔记==**

## 125——将一个正整数分解

```c
#include<stdio.h>

// 递归函数，计算分解方案数
int countWays(int n, int min) {
    if (n == 0) return 1; // 如果 n 为 0，表示找到一种有效的分解方案
    int count = 0;
    for (int i = min; i <= n; i++) { // 从 min 开始尝试分解 n
        count += countWays(n - i, i); // 递归调用，继续分解剩余的 n - i
    }
    return count; // 返回分解方案数
}

int main() {
    int n;
    printf("请输入一个正整数: ");
    scanf("%d", &n); // 输入一个正整数
    if (n <= 1) {
        printf("没有方案\n"); // 如果 n 小于等于 1，则没有有效的分解方案
    } else {
        // 减去1是因为至少要两个正整数之和
        printf("方案数: %d\n", countWays(n, 1) - 1); // 计算并输出分解方案数
    }
    return 0;
}

```

对于上述代码，表面上来说没什么特殊的，关键是注意countways中的另一个参数：min

### 解释 `countWays` 函数中的 `min` 参数

`min` 参数在 `countWays` 函数中起到了限制最小分解数的作用。以下是详细解释：

test_125.c

#### `min` 参数的作用

1. **限制最小分解数**:
   - `min` 参数确保在递归过程中，每次分解时使用的数不会小于上一次分解时使用的数。
   - 例如，如果当前分解数为 `i`，那么下一次递归调用时，最小分解数将是 `i`，即 `countWays(n - i, i)`。
2. **避免重复方案**:
   - 通过限制最小分解数，避免了重复计算相同的分解方案。例如，分解 5 为 2+3 和 3+2 是相同的方案，通过 `min` 参数可以避免这种重复。
3. **递归终止条件**:
   - 当 `n` 为 0 时，表示找到了一种有效的分解方案，返回 1。
   - 递归过程中，`min` 参数逐步增加，确保每次分解时使用的数不会小于上一次，从而保证了方案的唯一性和有效性。

总结来说，`min` 参数在 `countWays` 函数中起到了限制最小分解数和避免重复方案的作用，确保了递归过程中的分解方案是唯一且有效的。

**==同时，要注意这个代码一开始在函数中并没有限制1与0的正整数分解，这是为了减少干扰==**

## 126——01串

需要注意这个问题，卡了我好长时间：

**当我写为x+(1<<(n-1))就可以了，但是当我写为x+1<<(n-1)时在最后一步就不行，这是为啥呢么？**

这是因为运算符的优先级问题。

在表达式 `x + 1 << (n-1)` 中，运算符 `+` 和 `<<` 的优先级不同。具体来说，位移运算符 `<<` 的优先级低于加法运算符 `+`。因此，表达式 `x + 1 << (n-1)` 会被解析为 `(x + 1) << (n-1)`，而不是 `x + (1 << (n-1))`。

### 具体解释

- `x + 1 << (n-1)` 被解析为 `(x + 1) << (n-1)`：
  - 先计算 `x + 1`，得到一个中间结果。
  - 然后对这个中间结果进行左移 `(n-1)` 位。
- `x + (1 << (n-1))`：
  - 先计算 `1 << (n-1)`，得到一个中间结果。
  - 然后将 `x` 加上这个中间结果。

### 示例

假设 `x = 2`，`n = 3`：

- `x + 1 << (n-1)`：
  - 先计算 `x + 1`，即 `2 + 1 = 3`。
  - 然后计算 `3 << 2`，即 `3 * 2^2 = 3 * 4 = 12`。
- `x + (1 << (n-1))`：
  - 先计算 `1 << 2`，即 `1 * 2^2 = 4`。
  - 然后计算 `2 + 4 = 6`。

### 解决方法

为了确保运算顺序正确，你需要使用括号来明确表达式的优先级：

chains(n-1, x + (1 << (n-1)), y+1);

这样可以确保先进行位移操作，然后再进行加法运算。 这样可以确保先进行位移操作，然后再进行加法运算。

## 127