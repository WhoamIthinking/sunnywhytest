# sunnywhy算法笔记

**==从现在开始这几道题遇到不会的我就开始写笔记==**

## 125——将一个正整数分解

```c
#include<stdio.h>

// 递归函数，计算分解方案数
int countWays(int n, int min) {
    if (n == 0) return 1; // 如果 n 为 0，表示找到一种有效的分解方案
    int count = 0;
    for (int i = min; i <= n; i++) { // 从 min 开始尝试分解 n
        count += countWays(n - i, i); // 递归调用，继续分解剩余的 n - i
    }
    return count; // 返回分解方案数
}

int main() {
    int n;
    printf("请输入一个正整数: ");
    scanf("%d", &n); // 输入一个正整数
    if (n <= 1) {
        printf("没有方案\n"); // 如果 n 小于等于 1，则没有有效的分解方案
    } else {
        // 减去1是因为至少要两个正整数之和
        printf("方案数: %d\n", countWays(n, 1) - 1); // 计算并输出分解方案数
    }
    return 0;
}

```

对于上述代码，表面上来说没什么特殊的，关键是注意countways中的另一个参数：min

### 解释 `countWays` 函数中的 `min` 参数

`min` 参数在 `countWays` 函数中起到了限制最小分解数的作用。以下是详细解释：

test_125.c

#### `min` 参数的作用

1. **限制最小分解数**:
   - `min` 参数确保在递归过程中，每次分解时使用的数不会小于上一次分解时使用的数。
   - 例如，如果当前分解数为 `i`，那么下一次递归调用时，最小分解数将是 `i`，即 `countWays(n - i, i)`。
2. **避免重复方案**:
   - 通过限制最小分解数，避免了重复计算相同的分解方案。例如，分解 5 为 2+3 和 3+2 是相同的方案，通过 `min` 参数可以避免这种重复。
3. **递归终止条件**:
   - 当 `n` 为 0 时，表示找到了一种有效的分解方案，返回 1。
   - 递归过程中，`min` 参数逐步增加，确保每次分解时使用的数不会小于上一次，从而保证了方案的唯一性和有效性。

总结来说，`min` 参数在 `countWays` 函数中起到了限制最小分解数和避免重复方案的作用，确保了递归过程中的分解方案是唯一且有效的。

**==同时，要注意这个代码一开始在函数中并没有限制1与0的正整数分解，这是为了减少干扰==**

## 128——01串

需要注意这个问题，卡了我好长时间：

**当我写为x+(1<<(n-1))就可以了，但是当我写为x+1<<(n-1)时在最后一步就不行，这是为啥呢么？**

这是因为运算符的优先级问题。

在表达式 `x + 1 << (n-1)` 中，运算符 `+` 和 `<<` 的优先级不同。具体来说，位移运算符 `<<` 的优先级低于加法运算符 `+`。因此，表达式 `x + 1 << (n-1)` 会被解析为 `(x + 1) << (n-1)`，而不是 `x + (1 << (n-1))`。

### 具体解释

- `x + 1 << (n-1)` 被解析为 `(x + 1) << (n-1)`：
  - 先计算 `x + 1`，得到一个中间结果。
  - 然后对这个中间结果进行左移 `(n-1)` 位。
- `x + (1 << (n-1))`：
  - 先计算 `1 << (n-1)`，得到一个中间结果。
  - 然后将 `x` 加上这个中间结果。

### 示例

假设 `x = 2`，`n = 3`：

- `x + 1 << (n-1)`：
  - 先计算 `x + 1`，即 `2 + 1 = 3`。
  - 然后计算 `3 << 2`，即 `3 * 2^2 = 3 * 4 = 12`。
- `x + (1 << (n-1))`：
  - 先计算 `1 << 2`，即 `1 * 2^2 = 4`。
  - 然后计算 `2 + 4 = 6`。

### 解决方法

为了确保运算顺序正确，你需要使用括号来明确表达式的优先级：

chains(n-1, x + (1 << (n-1)), y+1);

这样可以确保先进行位移操作，然后再进行加法运算。 这样可以确保先进行位移操作，然后再进行加法运算。

## 129——生成子集

```c
#include<stdio.h>
#include<stdlib.h>
#include<math.h>

int a[5000][12];

void generate(int n){
    int i=0;
    int j;
    for(i=0;i<pow(2,n);i++){
        for(j=0;j<n;j++){
            if(i&(1<<j)){
                a[i][j]=1;
            }
        }
    }
}

// 比较函数，用于qsort排序
int compare(const void *p1, const void *p2) {
    int *arrA = (int *)p1;
    int *arrB = (int *)p2;
    int sizeA = 0, sizeB = 0;

    // 计算子集的大小
    for (int i = 0; i < 12; i++) {
        if (arrA[i] == 1) sizeA++;
        if (arrB[i] == 1) sizeB++;
    }

    // 按子集大小排序
    if (sizeA != sizeB) return sizeA - sizeB;

    // 如果大小相同，按字典序排序
    for (int i = 0; i < 12; i++) {
        if (arrA[i] != arrB[i]) return arrA[i] - arrB[i];
    }

    return 0;
}

// 排序函数
void mysort(int n) {
    qsort(a, (int)pow(2, n), sizeof(a[0]), compare);
}

int main(){
    int n;
    scanf("%d",&n);
    int i=0,j=0;
    for(i=0;i<pow(2,n);i++){
        for(j=0;j<n;j++){
            a[i][j]=0;
        }
    }
    generate(n);
    mysort(n);
    for(i=0;i<pow(2,n);i++){
        for(j=0;j<n;j++){
            if(a[i][j]==1){
                printf("%d ",j+1);
            }
        }
        printf("\n");
    }
    return 0;
}
```

本题的解法我参考了人工智能，是一个非常巧妙的解法，因为任意一个长度为n的集合都最多可以分解为pow(2,n)(即2的n次方)个子集。而对n，利用上题中的01串，刚好能化为2的n次方的串，故用此来表示

### 代码功能
这段代码的主要功能是生成一个正整数 `n` 的所有子集，并对这些子集进行排序。排序规则是：
1. 子集的元素个数少的优先。
2. 元素个数相同的子集按字典序排序。

### 代码结构
1. **全局变量**：
   ```c
   int a[5000][12];
   ```
   这是一个二维数组，用于存储所有子集。假设 `n` 的最大值为 12，因此最多有 `2^12 = 4096` 个子集，每个子集最多包含 12 个元素。

2. **生成子集的函数 `generate`**：
   ```c
   void generate(int n) {
       int i = 0;
       int j;
       for (i = 0; i < pow(2, n); i++) {
           for (j = 0; j < n; j++) {
               if (i & (1 << j)) {
                   a[i][j] = 1;
               }
           }
       }
   }
   ```
   这个函数生成所有子集，并将它们存储在全局数组 `a` 中。外层循环遍历所有可能的子集，总共有 `2^n` 个子集。内层循环遍历每个元素，通过位运算 `i & (1 << j)` 检查当前子集是否包含第 `j` 个元素。如果包含，则将 `a[i][j]` 设置为 1。

   **举例说明**：
   假设 `n = 3`，则有 `2^3 = 8` 个子集。对于每个 `i`，内层循环检查每个元素是否在子集中：
   - `i = 0`：子集为空集 `{}`
   - `i = 1`：子集为 `{1}`
   - `i = 2`：子集为 `{2}`
   - `i = 3`：子集为 `{1, 2}`
   - `i = 4`：子集为 `{3}`
   - `i = 5`：子集为 `{1, 3}`
   - `i = 6`：子集为 `{2, 3}`
   - `i = 7`：子集为 `{1, 2, 3}`

3. **比较函数 `compare`**：
   ```c
   int compare(const void *p1, const void *p2) {
       int *arrA = (int *)p1;
       int *arrB = (int *)p2;
       int sizeA = 0, sizeB = 0;
   
       // 计算子集的大小
       for (int i = 0; i < 12; i++) {
           if (arrA[i] == 1) sizeA++;
           if (arrB[i] == 1) sizeB++;
       }
   
       // 按子集大小排序
       if (sizeA != sizeB) return sizeA - sizeB;
   
       // 如果大小相同，按字典序排序
       for (int i = 0; i < 12; i++) {
           if (arrA[i] != arrB[i]) return arrB[i] - arrA[i];
       }
   
       return 0;
   }
   ```
   这个函数用于 `qsort` 函数的比较器，按照子集大小和字典序排序。首先计算两个子集的大小，然后按大小排序。如果大小相同，则按字典序排序。

   ==`qsort(a, (int)pow(2, n), sizeof(a[0]), compare);` 这个函数的作用是对数组 `a` 进行排序。==具体来说：
   
   - `a` 是要排序的数组。
   - `(int)pow(2, n)` 是数组 `a` 中元素的数量，即子集的总数。
   - `sizeof(a[0])` 是数组 `a` 中每个元素的大小。
   - `compare` 是一个比较函数，用于确定两个元素的顺序。
   
   `qsort` 函数会根据 `compare` 函数的结果对数组 `a` 进行排序，使得子集按照指定的顺序排列。
   
   
   
   **同时要明白`qsort` 函数可以对二维数组进行排序，因为二维数组实际上是一个指针数组。`qsort` 函数通过比较函数 `compare` 来确定两个元素的顺序。具体来说，`qsort` 会将数组中的每一行视为一个元素，并使用 `compare` 函数来比较这些行。**
   
   
   
   **`sizeof(a[0])` 是数组 `a` 中每一行的大小，因为 `a` 是一个二维数组，`a[0]` 表示数组 `a` 的第一行。对于二维数组 `int a[5000][12]`，`a[0]` 是一个包含 12 个 `int` 元素的一维数组。因此，`sizeof(a[0])` 返回的是这个一维数组的大小，即 12 个 `int` 元素的大小。**
   
   **具体来说，`sizeof(a[0])` 等于 `12 * sizeof(int)`，表示数组 `a` 中每一行的大小。**
   
   
   
4. **主函数 `main`**：
   
   ```c
   int main() {
       int n;
       scanf("%d", &n);
       int i = 0, j = 0;
       for (i = 0; i < pow(2, n); i++) {
           for (j = 0; j < n; j++) {
               a[i][j] = 0;
           }
       }
       generate(n);
       mysort(n);
       for (i = 0; i < pow(2, n); i++) {
           for (j = 0; j < n; j++) {
               if (a[i][j] == 1) {
                   printf("%d ", j + 1);
               }
           }
           printf("\n");
       }
       return 0;
   }
   ```
   主函数读取输入的整数 `n`，初始化数组 `a`，调用 `generate` 函数生成所有子集，调用 `mysort` 函数对子集进行排序，最后打印所有子集。

### 举例说明
假设输入 `n = 3`，则生成的子集和排序结果如下：
- 生成的子集：
  ```
  {}
  {1}
  {2}
  {1, 2}
  {3}
  {1, 3}
  {2, 3}
  {1, 2, 3}
  ```
- 排序后的子集：
  ```
  {}
  {1}
  {2}
  {3}
  {1, 2}
  {1, 3}
  {2, 3}
  {1, 2, 3}。
  ```

最后还要考虑行末不能有空格，可以做如下修改：

```c
  for(i=0;i<pow(2,n);i++){
        int first = 1; // 标记是否是第一个元素
        for(j=0;j<n;j++){
            if(a[i][j]==1){
                if (!first) {
                    printf(" ");
                }
                printf("%d", j+1);
                first = 0;
            }
        }
        printf("\n");
    }
```

==**使用first标记用于判断是不是第一个元素**==

## 130——